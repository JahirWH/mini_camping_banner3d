<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banner Camping</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #container {
            width: 100%;
            height: 250px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let tipi, trees = [], lake;

        function init() {
            const container = document.getElementById('container');
            
            // Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a1a, 10, 25);

            // Cámara para formato banner
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(7, 4, 7);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x1a1a1a, 1);
            container.appendChild(renderer.domElement);

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -15;
            directionalLight.shadow.camera.right = 15;
            directionalLight.shadow.camera.top = 15;
            directionalLight.shadow.camera.bottom = -15;
            scene.add(directionalLight);

            // Suelo con textura
            const groundGeometry = new THREE.CircleGeometry(20, 32);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0d0d0d,
                roughness: 0.95,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Crear lago
            createLake();

            // Crear tipi
            createTipi();

            // Crear fogata
            createCampfire();

            // Crear árboles naturales
            createNaturalTrees();

            // Rocas decorativas
            createRocks();

            // Eventos
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createTipi() {
            tipi = new THREE.Group();

            // Cono principal del tipi
            const tipiGeometry = new THREE.ConeGeometry(1.2, 2.5, 8);
            const tipiMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                roughness: 0.8,
                side: THREE.DoubleSide
            });
            const tipiCone = new THREE.Mesh(tipiGeometry, tipiMaterial);
            tipiCone.position.y = 1.25;
            tipiCone.castShadow = true;
            tipiCone.receiveShadow = true;
            tipi.add(tipiCone);

            // Palos que salen por arriba
            const stickGeometry = new THREE.CylinderGeometry(0.03, 0.03, 3.2, 6);
            const stickMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a
            });

            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const stick = new THREE.Mesh(stickGeometry, stickMaterial);
                stick.position.set(
                    Math.cos(angle) * 0.9,
                    1.8,
                    Math.sin(angle) * 0.9
                );
                stick.rotation.z = Math.cos(angle) * 0.15;
                stick.rotation.x = Math.sin(angle) * 0.15;
                stick.castShadow = true;
                tipi.add(stick);
            }

            // Entrada del tipi
            const doorGeometry = new THREE.CircleGeometry(0.4, 8);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                side: THREE.DoubleSide
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.5, 1.15);
            door.rotation.y = Math.PI;
            tipi.add(door);

            // Decoración: líneas en el tipi
            const stripeGeometry = new THREE.TorusGeometry(1.15, 0.03, 8, 16);
            const stripeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a
            });
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.y = 1;
            stripe.rotation.x = Math.PI / 2;
            tipi.add(stripe);

            tipi.position.set(1, 0, 0);
            scene.add(tipi);
        }

        function createCampfire() {
            const campfire = new THREE.Group();

            // Troncos en círculo
            const logGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
            const logMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a
            });

            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const log = new THREE.Mesh(logGeometry, logMaterial);
                log.position.set(
                    Math.cos(angle) * 0.25,
                    0.15,
                    Math.sin(angle) * 0.25
                );
                log.rotation.z = Math.PI / 2;
                log.rotation.y = angle;
                log.castShadow = true;
                campfire.add(log);
            }

            // Fuego (pirámide brillante)
            const fireGeometry = new THREE.ConeGeometry(0.3, 0.6, 4);
            const fireMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00,
                emissive: 0xff6600,
                emissiveIntensity: 0.8
            });
            const fire = new THREE.Mesh(fireGeometry, fireMaterial);
            fire.position.y = 0.4;
            campfire.add(fire);

            campfire.position.set(-1.5, 0, 1.5);
            scene.add(campfire);
        }

        function createLake() {
            // Lago irregular
            const lakeShape = new THREE.Shape();
            const points = [];
            const segments = 16;
            
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const radius = 2.5 + Math.sin(i * 3) * 0.5;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                points.push(new THREE.Vector2(x, y));
            }
            
            lakeShape.setFromPoints(points);
            
            const lakeGeometry = new THREE.ShapeGeometry(lakeShape);
            const lakeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.1,
                metalness: 0.8,
                emissive: 0x0a0a0a,
                emissiveIntensity: 0.2
            });
            
            lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(-4, 0.02, -2);
            lake.receiveShadow = true;
            scene.add(lake);

            // Bordes del lago con piedritas
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const radius = 2.5 + Math.sin(i * 3) * 0.5;
                const pebbleGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6);
                const pebbleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x3a3a3a
                });
                const pebble = new THREE.Mesh(pebbleGeometry, pebbleMaterial);
                pebble.position.set(
                    -4 + Math.cos(angle) * radius,
                    0.05,
                    -2 + Math.sin(angle) * radius
                );
                pebble.castShadow = true;
                scene.add(pebble);
            }
        }

        function createNaturalTree(x, z, scale = 1, type = 0) {
            const tree = new THREE.Group();

            // Tronco irregular
            const trunkGeometry = new THREE.CylinderGeometry(
                0.15 * scale, 
                0.25 * scale, 
                2 * scale, 
                8
            );
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.95
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1 * scale;
            trunk.castShadow = true;
            tree.add(trunk);

            // Copa del árbol - estilo más natural
            const foliageMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0f0f0,
                roughness: 0.85
            });

            if (type === 0) {
                // Árbol frondoso con esferas
                for (let i = 0; i < 4; i++) {
                    const size = (0.6 + Math.random() * 0.3) * scale;
                    const foliageGeometry = new THREE.SphereGeometry(size, 8, 6);
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.set(
                        (Math.random() - 0.5) * 0.6 * scale,
                        (2 + Math.random() * 0.5) * scale,
                        (Math.random() - 0.5) * 0.6 * scale
                    );
                    foliage.castShadow = true;
                    tree.add(foliage);
                }
            } else {
                // Árbol tipo pino irregular
                for (let i = 0; i < 3; i++) {
                    const size = (1.2 - i * 0.3) * scale;
                    const height = (1.3 - i * 0.2) * scale;
                    const foliageGeometry = new THREE.ConeGeometry(size, height, 6);
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.y = (2.2 + i * 0.7) * scale;
                    foliage.rotation.y = Math.random() * Math.PI;
                    foliage.castShadow = true;
                    tree.add(foliage);
                }
            }

            tree.position.set(x, 0, z);
            tree.rotation.y = Math.random() * Math.PI * 2;
            scene.add(tree);
            trees.push(tree);
        }

        function createNaturalTrees() {
            // Árboles variados alrededor
            const positions = [
                [-6, -4, 1, 0], [-7, 0, 1.2, 1], [-6, 3, 0.9, 0],
                [5, -4, 1.1, 1], [6, 0, 0.8, 0], [5, 4, 1, 1],
                [-3, -6, 0.9, 1], [3, -6, 1.1, 0],
                [0, 6, 0.8, 1], [-2, 5, 1, 0], [2, 5, 0.9, 1],
                [-8, -2, 0.7, 0], [7, 2, 0.85, 1]
            ];

            positions.forEach(pos => {
                createNaturalTree(pos[0], pos[1], pos[2], pos[3]);
            });
        }

        function createRocks() {
            // Rocas decorativas cerca del tipi
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = 2 + Math.random() * 0.5;
                const rockGeometry = new THREE.DodecahedronGeometry(0.2 + Math.random() * 0.15, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    roughness: 0.9
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    1 + Math.cos(angle) * radius,
                    0.1,
                    Math.sin(angle) * radius
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0002;
            
            // Rotación suave de la cámara
            camera.position.x = Math.cos(time) * 8;
            camera.position.z = Math.sin(time) * 8;
            camera.position.y = 4;
            camera.lookAt(0, 0.5, 0);

            // Balanceo natural de árboles
            trees.forEach((tree, index) => {
                tree.rotation.z = Math.sin(time * 2 + index) * 0.02;
            });

            // Reflejo sutil en el lago
            if (lake) {
                lake.material.emissiveIntensity = 0.2 + Math.sin(time * 3) * 0.05;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>